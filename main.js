/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var de=Object.create;var M=Object.defineProperty;var he=Object.getOwnPropertyDescriptor;var ue=Object.getOwnPropertyNames;var ge=Object.getPrototypeOf,me=Object.prototype.hasOwnProperty;var fe=(u,f)=>{for(var e in f)M(u,e,{get:f[e],enumerable:!0})},te=(u,f,e,t)=>{if(f&&typeof f=="object"||typeof f=="function")for(let s of ue(f))!me.call(u,s)&&s!==e&&M(u,s,{get:()=>f[s],enumerable:!(t=he(f,s))||t.enumerable});return u};var B=(u,f,e)=>(e=u!=null?de(ge(u)):{},te(f||!u||!u.__esModule?M(e,"default",{value:u,enumerable:!0}):e,u)),we=u=>te(M({},"__esModule",{value:!0}),u);var xe={};fe(xe,{default:()=>O});module.exports=we(xe);var d=require("obsidian"),ne=require("child_process"),R=B(require("fs")),L=B(require("path")),se=require("util"),ie=B(require("os")),ae=require("crypto"),oe=require("url"),ve=(0,se.promisify)(R.mkdtemp),S="r-environment-view",D="r-help-view",ye={rExecutablePath:"/usr/local/bin/R",rstudioPandocPath:"/opt/homebrew/bin/"},U=class extends d.ItemView{constructor(e){super(e);this.environmentData=[];this.noteTitle=""}getViewType(){return S}getDisplayText(){return"R Environment"}getIcon(){return"table"}async onOpen(){console.log("REnvironmentView opened"),this.containerEl.empty(),this.render()}async onClose(){console.log("REnvironmentView closed")}updateEnvironmentData(e,t){console.log(`Updating environment data for note: ${e}`,t),this.noteTitle=e,this.environmentData=t,this.render()}render(){console.log("REnvironmentView render called with data:",this.environmentData),this.containerEl.empty();let e=document.createElement("div");e.style.padding="10px",e.style.overflowY="auto";let t=document.createElement("h5");t.textContent=`R environment for ${this.noteTitle}`,t.style.fontFamily='"Poppins", sans-serif',t.style.fontSize="18px",t.style.fontWeight="600",t.style.marginBottom="15px",t.style.padding="10px",t.style.borderRadius="8px",t.style.textAlign="center",t.classList.add("theme-aware-title"),e.appendChild(t);let s=document.createElement("table");s.style.width="100%",s.style.borderCollapse="separate",s.style.borderSpacing="0",s.style.fontFamily="'Monaco', 'monospace'",s.style.whiteSpace="nowrap",s.style.overflow="hidden",s.style.borderRadius="12px",s.style.tableLayout="fixed",s.style.border="1px solid rgba(200, 200, 200, 0.3)",s.classList.add("theme-aware-table");let n=document.createElement("tr");["Name","Type","Size","Value"].forEach((o,a)=>{let i=document.createElement("th");i.textContent=o,i.style.padding="12px",i.style.textAlign="left",i.style.fontFamily='"Poppins", sans-serif',i.style.fontSize="12px",i.style.fontWeight="600",i.style.borderBottom="2px solid rgba(200, 200, 200, 0.5)",i.style.borderRight="1px solid rgba(200, 200, 200, 0.3)",o==="Type"&&(i.style.width="90px"),o==="Size"&&(i.style.width="80px"),o==="Name"&&(i.style.width="60px"),n.appendChild(i)}),s.appendChild(n),this.environmentData.forEach(o=>{let a=document.createElement("tr");a.style.transition="background-color 0.3s",a.style.borderRadius="12px",a.classList.add("theme-aware-row"),a.addEventListener("mouseover",()=>{a.style.backgroundColor="var(--hover-background-color)"}),a.addEventListener("mouseout",()=>{a.style.backgroundColor="var(--row-background-color)"});let i=(P,C="left")=>{let g=document.createElement("td");return g.textContent=P,g.style.padding="12px",g.style.borderBottom="1px solid rgba(200, 200, 200, 0.5)",g.style.borderRight="1px solid rgba(200, 200, 200, 0.3)",g.style.textAlign=C,g.style.fontSize="12px",g.style.overflow="hidden",g.style.textOverflow="ellipsis",g.classList.add("theme-aware-cell"),C==="left"&&P===o.value&&(g.style.width="65%"),g},h=i(o.name);a.appendChild(h);let m=i(Array.isArray(o.type)?o.type.join(", "):o.type);a.appendChild(m);function y(P){let C=["B","KB","MB","GB","TB"];if(P==0)return"0 Byte";let g=Math.floor(Math.log(P)/Math.log(1024));return(P/Math.pow(1024,g)).toFixed(1)+" "+C[g]}let p=i(y(o.size),"right");a.appendChild(p);let x=Array.isArray(o.value)?o.value.slice(0,5).join(", ")+" ...":o.value.toString(),v=i(x);v.style.whiteSpace="nowrap",v.style.width="65%",a.appendChild(v),s.appendChild(a)}),e.appendChild(s),this.containerEl.appendChild(e);let w=document.createElement("style");w.textContent=`
      .theme-aware-title, .theme-aware-table, .theme-aware-cell, .theme-aware-row {
        color: var(--text-normal);
        background: var(--background-primary);
      }
      .theme-aware-row {
        background: var(--background-secondary);
      }
      .theme-aware-row:hover {
        background: var(--background-hover);
      }
      .theme-aware-table th {
        color: var(--text-muted);
      }
    `,document.head.appendChild(w)}},j=class extends d.ItemView{constructor(e){super(e);this.helpContent=""}getViewType(){return D}getDisplayText(){return"R Help"}getIcon(){return"info"}async onOpen(){console.log("RHelpView opened"),this.contentEl.empty(),this.render()}async onClose(){console.log("RHelpView closed")}updateHelpContent(e){console.log("Updating help content in RHelpView with content:",e),this.helpContent=e,this.render()}render(){console.log("RHelpView render called with help content:",this.helpContent),this.contentEl.empty();let e=document.createElement("div");e.style.padding="1px",e.style.overflowY="auto",e.style.fontFamily="sans-serif",e.innerHTML=this.helpContent;let t=document.createElement("style");t.innerHTML=`
        code {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
        }
    `,e.appendChild(t),this.contentEl.appendChild(e)}},z=class extends d.PluginSettingTab{constructor(e,t){super(e,t);this.plugin=t}display(){let{containerEl:e}=this;e.empty(),e.createEl("h2",{text:"R Integration Settings"}),new d.Setting(e).setName("Path to R Executable").setDesc("Specify the full path to your R executable.").addText(t=>t.setPlaceholder("/usr/local/bin/R").setValue(this.plugin.settings.rExecutablePath).onChange(async s=>{let n=s.trim();console.log("R Executable Path changed to: "+n),R.existsSync(n)&&R.statSync(n).isDirectory()?(this.plugin.settings.rExecutablePath=n,await this.plugin.saveSettings(),new d.Notice("R executable path updated successfully.")):(new d.Notice("Invalid R executable path. Please enter a valid path."),console.error("Invalid R executable path provided:",n))})),new d.Setting(e).setName("Path to RStudio Pandoc").setDesc("Specify the full path to your RStudio Pandoc installation.").addText(t=>t.setPlaceholder("/opt/homebrew/bin/").setValue(this.plugin.settings.rstudioPandocPath).onChange(async s=>{let n=s.trim();console.log("RStudio Pandoc Path changed to: "+n),R.existsSync(n)&&R.statSync(n).isDirectory()?(this.plugin.settings.rstudioPandocPath=n,await this.plugin.saveSettings(),new d.Notice("RStudio Pandoc path updated successfully.")):(new d.Notice("Invalid RStudio Pandoc path. Please enter a valid directory path."),console.error("Invalid RStudio Pandoc path provided:",n))}))}},O=class extends d.Plugin{constructor(){super(...arguments);this.rProcesses=new Map}generateUniqueId(e){return(0,ae.createHash)("sha256").update(e.toString()).digest("hex").substring(0,8)}async loadSettings(){this.settings=Object.assign({},ye,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}async onload(){console.log("Loading R Code Evaluator Plugin"),await this.loadSettings(),this.addSettingTab(new z(this.app,this)),this.registerView(S,e=>new U(e)),this.registerView(D,e=>new j(e)),this.app.workspace.onLayoutReady(()=>{if(console.log("Workspace is ready, adding R Environment and Help views"),this.app.workspace.getLeavesOfType(S).length===0){let e=this.app.workspace.getRightLeaf(!1);e?e.setViewState({type:S,active:!0}).then(()=>{console.log("REnvironmentView added to the right pane")}).catch(t=>{console.error("Failed to add REnvironmentView to the right pane:",t)}):console.error("Failed to obtain the right workspace leaf for REnvironmentView.")}else console.log("REnvironmentView already exists in the workspace");if(this.app.workspace.getLeavesOfType(D).length===0){let e=this.app.workspace.getRightLeaf(!0);e?e.setViewState({type:D,active:!0}).then(()=>{console.log("RHelpView added to the right pane")}).catch(t=>{console.error("Failed to add RHelpView to the right pane:",t)}):console.error("Failed to obtain the right workspace leaf for RHelpView.")}else console.log("RHelpView already exists in the workspace")}),this.addCommand({id:"run-current-code-chunk",name:"Run Current Code Chunk",editorCallback:(e,t)=>{if(!t.file){new d.Notice("No file associated with the current view."),console.error("No file associated with the current view.");return}let s=t.file.basename;this.runCurrentCodeChunk(e,t,s)},hotkeys:[{modifiers:["Mod"],key:"r"}]}),console.log("R Code Evaluator Plugin loaded successfully")}onunload(){console.log("Unloading R Code Evaluator Plugin"),this.rProcesses.forEach((e,t)=>{console.log(`Terminating R process for note: ${t}`),e.kill()}),this.rProcesses.clear(),this.app.workspace.getLeavesOfType(S).forEach(e=>{console.log("Detaching REnvironmentView from workspace"),e.detach()}),console.log("R Code Evaluator Plugin unloaded successfully")}runCurrentCodeChunk(e,t,s){var a;let n=e.getCursor(),{startLine:l,endLine:c,code:w,existingLabel:o}=this.getCurrentCodeChunk(e,n.line);if(w){let i=o||this.generateUniqueId(l),h=(a=t.file)==null?void 0:a.path;if(h){o||this.insertLabel(e,l,i),console.log(`Running current code chunk in note: ${h} with ID: ${i}`);let m=/\?\s*\w+/.test(w)||/help\s*\(\s*\w+\s*\)/.test(w);this.runRCodeInSession(h,w,s,i,m).then(({result:y,imagePaths:p,widgetPaths:x,helpContent:v})=>{console.log("R code executed successfully"),m?new d.Notice("Help content updated in the sidebar."):this.insertOutputWithCallout(e,c,y,p,x,i)}).catch(y=>{console.error("Error executing R code:",y),this.insertOutputWithCallout(e,c,`Error:
${y}`,[],[],i)})}else new d.Notice("No file associated with the current view."),console.error("No file associated with the current view.")}else new d.Notice("No R code chunk found at the cursor position."),console.log("No R code chunk found at the cursor position.")}getCurrentCodeChunk(e,t){let s=e.lineCount(),n=t,l=t,c=null;for(;n>=0&&!e.getLine(n).startsWith("```r");)n--;if(n<0)return{startLine:-1,endLine:-1,code:"",existingLabel:null};for(l=n+1;l<s&&!e.getLine(l).startsWith("```");)l++;if(l>=s)return{startLine:-1,endLine:-1,code:"",existingLabel:null};let w=[];for(let h=n+1;h<l;h++)w.push(e.getLine(h));let o=w.join(`
`),i=e.getLine(n).match(/\{#([^\}]+)\}/);return i&&(c=i[1]),console.log(`Found code chunk from line ${n} to ${l} with label: ${c}`),{startLine:n,endLine:l,code:o,existingLabel:c}}insertLabel(e,t,s){let n=e.getLine(t);if(n.includes("{#"))return;let l=n.replace(/```r/,`\`\`\`r {#${s}}`);e.setLine(t,l),console.log(`Inserted label {#${s}} into code chunk at line ${t}`)}insertOutputWithCallout(e,t,s,n,l,c){console.log("Inserting or updating output callout and images into the editor");let w=`> [!OUTPUT]+ {#output-${c}}
> 
`,o="> ",a=w,i=s.trim().split(`
`).map(p=>o+p);a+=i.join(`
`),n.forEach(p=>{let v=`![center| 480 ](${`${p}`})`;a+=`
${o} ${v}`}),l.forEach(p=>{let v=`<iframe src="${`${p}`}" width="100%" height="680px"></iframe>`;a+=`
${o} ${v}`}),a+=`
> 
`;let h=-1,m=-1,y=e.lineCount();for(let p=0;p<y;p++)if(e.getLine(p).trim()===`> [!OUTPUT]+ {#output-${c}}`){for(h=p,m=p;m+1<y;){let v=e.getLine(m+1);if(!v.startsWith("> ")&&v.trim()!=="")break;m++}break}if(h!==-1&&m!==-1){let p={line:h,ch:0},x={line:m+1,ch:0};e.replaceRange(a+`
`,p,x),console.log(`Replaced existing output callout for ID: ${c}`)}else{let p={line:t+1,ch:0};e.replaceRange(`
`+a+`
`,p),console.log(`Inserted new output callout for ID: ${c}`)}}getRProcess(e){let t=this.rProcesses.get(e);return t||(t=this.startRProcess(e)),t}startRProcess(e){let t=this.settings.rExecutablePath||"/usr/local/bin/R";if(console.log(`Starting R process for note: ${e} using executable: ${t}`),!R.existsSync(t))throw new d.Notice(`R executable not found at ${t}. Please update the path in settings.`),console.error(`R executable not found at ${t}.`),new Error(`R executable not found at ${t}.`);let s={...process.env},n=(0,ne.spawn)(t,["--vanilla","--quiet","--slave"],{stdio:"pipe",env:s});n.on("error",c=>{console.error(`Failed to start R process for ${e}:`,c)});let l=`
library(jsonlite)
if (!exists("user_env")) {
  user_env <- new.env()
}


# prevent browser:
options(browser='false')
options(bitmapType = 'cairo')
options(device = function(...) jpeg(filename = tempfile(), width=800, height=600, ...))
    `;return n.stdin.write(l+`
`),this.rProcesses.set(e,n),console.log(`R process started and stored for note: ${e}`),n}async runRCodeInSession(e,t,s,n,l){console.log("runRCodeInSession called for note:",e,"with ID:",n);let c=this.getRProcess(e);return new Promise(async(w,o)=>{let a="",i="",h=await ve(L.join(ie.tmpdir(),"rplots-")),m=h.replace(/\\/g,"/"),y=L.join(m,`help_${n}.txt`),p=y.replace(/\\/g,"/"),x=`__END_OF_OUTPUT__${Date.now()}__`,v="__PLOT_PATH__",P=`__ENVIRONMENT_DATA__${Date.now()}__`,C="__WIDGET_PATH__",g=`
library(evaluate)
library(jsonlite)
library(htmlwidgets)
Sys.setenv(RSTUDIO_PANDOC='${this.settings.rstudioPandocPath}')

# Define our custom print function
custom_print_htmlwidget <- function(x, ..., viewer = NULL) {
    # Generate a unique filename
    
    widgetFileName <- paste0("widget_${n}_",".html")
    widgetFilePath <- file.path("${m}", widgetFileName)
    # Save the widget to the file
    saveWidget(x, widgetFilePath, selfcontained = TRUE)
    # Output a marker to indicate the widget was saved
    cat("${C}", widgetFileName, "\\n", sep="")
}

# Replace the original function in the 'htmlwidgets' namespace
environment(custom_print_htmlwidget) <- asNamespace('htmlwidgets')
assignInNamespace("print.htmlwidget", custom_print_htmlwidget, envir = as.environment("package:htmlwidgets"))



timecheck <- Sys.time()

# override help
.getHelpFile <- function(file)
{
    path <- dirname(file)
    dirpath <- dirname(path)
    if(!file.exists(dirpath))
        stop(gettextf("invalid %s argument", sQuote("file")), domain = NA)
    pkgname <- basename(dirpath)
    RdDB <- file.path(path, pkgname)
    if(!file.exists(paste(RdDB, "rdx", sep = ".")))
        stop(gettextf("package %s exists but was not installed under R >= 2.10.0 so help cannot be accessed", sQuote(pkgname)), domain = NA)
    tools:::fetchRdDB(RdDB, basename(file))
}


print.help_files_with_topic <- function(x, ...)
{
  browser <- getOption("browser")
  topic <- attr(x, "topic")
  type <- "text"
  paths <- as.character(x)
  
  if(!length(paths)) {
    writeLines(c(gettextf("No documentation for %s in specified packages and libraries:",
                          sQuote(topic)),
                 gettextf("you could try %s",
                          sQuote(paste0("??", topic)))))
    return(invisible(x))
  }
  
  port <- NULL
  
  if(attr(x, "tried_all_packages")) {
    paths <- unique(dirname(dirname(paths)))
    msg <- gettextf("Help for topic %s is not in any loaded package but can be found in the following packages:",
                    sQuote(topic))
    
      writeLines(c(strwrap(msg), "",
                   paste(" ",
                         formatDL(c(gettext("Package"), basename(paths)),
                                  c(gettext("Library"), dirname(paths)),
                                  indent = 22))))
    } else {
    if(length(paths) > 1L) {
      file <- paths[1L]
      p <- paths
      msg <- gettextf("Help on topic %s was found in the following packages:",
                      sQuote(topic))
      paths <- dirname(dirname(paths))
      txt <- formatDL(c("Package", basename(paths)),
                      c("Library", dirname(paths)),
                      indent = 22L)
      writeLines(c(strwrap(msg), "", paste(" ", txt), ""))
      if(interactive()) {
        fp <- file.path(paths, "Meta", "Rd.rds")
        tp <- basename(p)
        titles <- tp
        if(type == "html" || type == "latex")
          tp <- tools::file_path_sans_ext(tp)
        for (i in seq_along(fp)) {
          tmp <- try(readRDS(fp[i]))
          titles[i] <- if(inherits(tmp, "try-error"))
            "unknown title" else
              tmp[tools::file_path_sans_ext(tmp$File) == tp[i], "Title"]
        }
        txt <- paste0(titles, " {", basename(paths), "}")
        ## the default on menu() is currtently graphics = FALSE
        res <- menu(txt, title = gettext("Choose one"),
                    graphics = getOption("menu.graphics"))
        if(res > 0) file <- p[res]
      } else {
        writeLines(gettext("
Using the first match ..."))
      }
    }
    else
      file <- paths
    
    if(type == "text") {
      pkgname <- basename(dirname(dirname(file)))
      tools::Rd2HTML(.getHelpFile(file), out = "${y}",
                            package = pkgname)

    }
    
  }
  
  invisible(x)
}

# Ensure user environment exists
if (!exists("user_env")) {
  user_env <- new.env()
}
# Evaluate code and capture results
results <- evaluate(${JSON.stringify(t)}, envir = user_env)

# Initialize outputs and image paths
outputs <- character()
imagePaths <- character()

# Process the results
for (res in results) {
  if (inherits(res, "source")) {
    # Ignore source elements
  } else if (inherits(res, "warning")) {
    outputs <- c(outputs, paste("Warning:", conditionMessage(res)))
  } else if (inherits(res, "message")) {
    outputs <- c(outputs, conditionMessage(res))
  } else if (inherits(res, "error")) {
    outputs <- c(outputs, paste("Error:", conditionMessage(res)))
  } else if (inherits(res, "character")) {

      val_str <- res
      outputs <- c(outputs, val_str)

  } else if (inherits(res, "recordedplot")) {
    # Save the plot to a file using uniqueId
    timestamp <- format(Sys.time(), "%Y%m%d%H%M%S")
    plotFileName <- paste0("plot_${n}_", length(imagePaths) + 1, "_", timestamp, ".jpg")
    plotFilePath <- file.path("${m}", plotFileName)
    jpeg(filename=plotFilePath, width=800, height=600)
    replayPlot(res)
    dev.off()
    imagePaths <- c(imagePaths, plotFileName)
  }
}

# Output the collected outputs
if (length(outputs) > 0) {
  cat(paste(outputs, collapse = "\\n"), "\\n")
}


# Attempt to retrieve the last animation, if any
if (requireNamespace("gganimate", quietly = TRUE)) {
  anim <- try(gganimate::last_animation(), silent = TRUE)
  
  
  
    if (is.character(anim[1])) {
    if(file.info(anim[1])$mtime > timecheck){
    # 'anim' is a file path to the GIF
    timestamp <- format(Sys.time(), "%Y%m%d%H%M%S")
    animFileName <- paste0("animation_${n}_", timestamp, ".gif")
    animFilePath <- file.path("${m}", animFileName)  # Corrected line
    file.copy(anim[1], animFilePath)
    imagePaths <- c(imagePaths, animFileName)
    }}
    
  
}

# Output image markers
for (img in imagePaths) {
  cat("${v}", img, "\\n", sep="")
}

# Output the environment data
vars <- ls(envir = user_env)
env_list <- lapply(vars, function(var_name) {
  var_value <- get(var_name, envir = user_env)
  var_class <- class(var_value)
  var_size <- as.numeric(object.size(var_value)) # Convert to numeric
  var_val <- capture.output(str(var_value, max.level=0))

  list(
    name = var_name,
    type = var_class,
    size = var_size,
    value = var_val
  )
})




env_json <- toJSON(env_list, auto_unbox = TRUE)
cat("${P}\\n")
cat(env_json)
cat("\\n${x}\\n")
      `;console.log(`Wrapped code sent to R:
`,g);let Q=async I=>{var G,J;let $=I.toString();if(console.log("Received data chunk:",$),a+=$,a.includes(x)){console.log("Marker detected in R output"),c.stdout.off("data",Q),c.stderr.off("data",Y);let E="",V="";if(l){try{let b=await R.promises.readFile(y,"utf8");console.log("Read help content:",b),V=b}catch(b){console.error("Failed to read help content:",b),V="Failed to retrieve help content."}let r=(G=this.app.workspace.getLeavesOfType(D)[0])==null?void 0:G.view;r?r.updateHelpContent(V):console.log("RHelpView not found in the workspace")}let H="";if(a.includes(P)){let r=a.split(P);E=r[0].trim(),H=r[1].split(x)[0].trim()}else E=a.split(x)[0].trim();console.log("Result before processing:",E),console.log("Environment data:",H);let q=v.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),F=[],re=new RegExp(`${q}(.*)`,"g"),N;for(;(N=re.exec(E))!==null;)if(console.log("Image regex match:",N),N[1]){let r=N[1].trim();F.push(r)}else console.error("No image file name captured in regex match:",N);E=E.replace(new RegExp(`${q}.*`,"g"),"").trim();for(let r of F){let b=L.join(h,r);try{let _=await R.promises.readFile(b),k=`plots/${r}`;this.app.vault.getAbstractFileByPath("plots")||(await this.app.vault.createFolder("plots"),console.log('Created "plots" folder in the vault'));let A=this.app.vault.getAbstractFileByPath(k);A?(await this.app.vault.modifyBinary(A,_),console.log(`Image file updated in vault: ${k}`)):(await this.app.vault.createBinary(k,_),console.log(`Image file created in vault: ${k}`)),F[F.indexOf(r)]=k}catch(_){console.error(`Error handling image file ${r}:`,_)}}let T=[],K=C.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),le=new RegExp(`${K}(.*)`,"g"),W;for(;(W=le.exec(E))!==null;)if(W[1]){let r=W[1].trim();T.push(r)}E=E.replace(new RegExp(`${K}.*`,"g"),"").trim();for(let r of T){let b=L.join(h,r);try{let _=await R.promises.readFile(b,"utf8"),k=`widgets/${r}`,Z=this.app.vault.adapter.getBasePath();this.app.vault.getAbstractFileByPath("widgets")||await this.app.vault.createFolder("widgets");let ee=this.app.vault.getAbstractFileByPath(k);ee?await this.app.vault.modify(ee,_):await this.app.vault.create(k,_);let ce=L.join(Z,k),pe=(0,oe.pathToFileURL)(ce).href;T[T.indexOf(r)]=pe}catch(_){console.error(`Error handling widget file ${r}:`,_)}}try{console.log(`Temporary directory ${h} removed`)}catch(r){console.error(`Error removing temporary directory ${h}:`,r)}let X=(J=this.app.workspace.getLeavesOfType(S)[0])==null?void 0:J.view;if(X){let r=[];try{r=JSON.parse(H),console.log("Parsed environment variables:",r)}catch(b){console.error("Failed to parse environment data JSON:",b)}X.updateEnvironmentData(s,r)}else console.log("REnvironmentView not found in the workspace");a="",i="",i?o(i.trim()):w({result:E,imagePaths:F,widgetPaths:T,helpContent:V})}},Y=I=>{let $=I.toString();console.error("Received error chunk from R:",$),i+=$};c.stdout.on("data",Q),c.stderr.on("data",Y),c.stdin.write(g+`
`),console.log("Wrapped R code sent to the R process")})}};
